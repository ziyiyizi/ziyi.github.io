<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>springboot项目启动后执行的类</title>
    <link href="undefined2020/01/09/PostStartClass/"/>
    <url>2020/01/09/PostStartClass/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot项目启动后执行的类"><a href="#springboot项目启动后执行的类" class="headerlink" title="springboot项目启动后执行的类"></a>springboot项目启动后执行的类</h1><pre><code>@Component@Slf4j@EnableBinding(PerformanceOutput.class)/** * 据实践 使用stream发送第一条消息均会失败 因此在启动后发送一条无效消息 以确保之后的消息不会出现此问题 */public class AfterServiceStartRunner implements ApplicationRunner {    @Autowired    private PerformanceOutput performanceOutput;    /**     * 会在服务启动完成后立即执行     */    @Override    public void run(ApplicationArguments args) throws Exception {        performanceOutput.output().send(MessageBuilderUtil.buildMessage(&quot;performance已启动&quot;, &quot;performance&quot;));    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot redis</title>
    <link href="undefined2020/01/09/springboot%20redis/"/>
    <url>2020/01/09/springboot%20redis/</url>
    
    <content type="html"><![CDATA[<h1 id="springboot-redis"><a href="#springboot-redis" class="headerlink" title="springboot redis"></a>springboot redis</h1><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><pre><code>spring.redis.database=0spring.redis.host=xxxspring.redis.port=6379spring.redis.password=</code></pre><h2 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h2><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><h2 id="use"><a href="#use" class="headerlink" title="use"></a>use</h2><pre><code>@Resourceprivate StringRedisTemplate stringRedisTemplate;stringRedisTemplate.opsForValue().set(AccountConst.TRANSACTION_ID + transactionId, TransactionalMessageStatus.commit.getMessage());String val = stringRedisTemplate.opsForValue().get(AccountConst.TRANSACTION_ID + transactionalId);</code></pre><h2 id="increment"><a href="#increment" class="headerlink" title="increment"></a>increment</h2><p><code>stringRedisTemplate.opsForValue().increment(KEY, INC_NUM)</code></p><ul><li>原子性加值</li><li>key不存在时会初始化为0</li></ul><h2 id="redisson-集群配置"><a href="#redisson-集群配置" class="headerlink" title="redisson(集群配置)"></a>redisson(集群配置)</h2><pre><code># redissonspring.redis.password =spring.redis.database = 1spring.redis.cluster.max-redirects = 3spring.redis.sentinel.master = master-1spring.redis.sentinel.nodes = #ip:port</code></pre><pre><code>@Configurationpublic class RedissonConfig {    @Value(&quot;${isProd:false}&quot;)    private boolean isProd;    @Value(&quot;${spring.redis.sentinel.nodes}&quot;)    private String redisUrl;    @Value(&quot;${spring.redis.password}&quot;)    private String password;    @Value(&quot;${spring.redis.database}&quot;)    private int database;    @Value(&quot;${spring.redis.sentinel.master}&quot;)    private String masterName;    @Bean(&quot;redisson&quot;)    public  Redisson getRedisson() {        Config config = new Config();        String prefix = &quot;redis://&quot;;        String[] nodes = redisUrl.split(&quot;,&quot;);        List&lt;String&gt; nodesList = new ArrayList&lt;&gt;(nodes.length);        Arrays.stream(nodes).forEach(node -&gt; nodesList.add(node.startsWith(prefix) ? node : prefix + node));        if (isProd) {            nodes = nodesList.toArray(new String[0]);            config.useSentinelServers().setMasterName(masterName).addSentinelAddress(nodes)                    .setPassword(password)                    .setDatabase(database);        } else {            config.useSingleServer().setDatabase(database).setAddress(nodesList.get(0).toString()).setPassword(password);        }        return (Redisson)Redisson.create(config);    }}</code></pre><pre><code>@Resource(name = &quot;redisson&quot;)private Redisson redisson;RLock rLock = redisson.getLock(LOCK_NAME);boolean isLock = rLock.tryLock(1, 60 * 60, TimeUnit.SECONDS);if (!isLock) {    log.error(&quot;定时任务锁已被其他机器相同服务占有，任务终止。&quot;);    return;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flyway集成</title>
    <link href="undefined2020/01/07/flyway%E9%9B%86%E6%88%90/"/>
    <url>2020/01/07/flyway%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="flyway集成"><a href="#flyway集成" class="headerlink" title="flyway集成"></a>flyway集成</h1><ul><li>引入pom依赖</li></ul><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;            &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;            &lt;version&gt;6.1.0&lt;/version&gt;        &lt;/dependency&gt;</code></pre><ul><li>properties 可有</li></ul><pre><code># 设为false，不对已经执行的sql进行内容校验spring.flyway.validate-on-migrate=false</code></pre><ul><li>resource文件夹下新加db文件夹 在db文件夹下新建migration文件夹 在migration文件夹下新建sql初始脚本 命名格式”VyyMMddHHmm__init.sql” 如下</li></ul><pre><code>USE `label_datastore`;SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;CREATE TABLE IF NOT EXISTS `t_user`(    `id`               VARCHAR(32) NOT NULL COMMENT &#39;用户ID&#39;,    `userName`         VARCHAR(255) DEFAULT NULL COMMENT &#39;用户名&#39;,    PRIMARY KEY (`id`) USING BTREE)    ENGINE = InnoDB    CHARACTER SET = utf8mb4    COLLATE = utf8mb4_unicode_ci    ROW_FORMAT = Dynamic    COMMENT = &#39;【用户】表&#39;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>flyway</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>flyway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务消息</title>
    <link href="undefined2020/01/02/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
    <url>2020/01/02/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Transactional-Message"><a href="#Transactional-Message" class="headerlink" title="Transactional Message"></a>Transactional Message</h1><blockquote><p>在微服务架构中，我们常常使用异步化的手段来提升系统的吞吐量和解耦系统，而构建异步架构最常用的手段就是使用消息队列(MQ)，那异步架构要怎样实现数据一致性呢？事务消息是不可或缺的一环。</p></blockquote><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>事务消息实现了消息生产者<strong>本地事务执行</strong>与<strong>消息发送</strong>的原子性，保证了消息生产者<strong>本地事务处理成功</strong>与<strong>消息发送成功</strong>的最终一致。</p><h2 id="一个场景"><a href="#一个场景" class="headerlink" title="一个场景"></a>一个场景</h2><blockquote><p>订单系统：生成订单记录 -&gt; MQ -&gt; 积分系统：增加积分</p></blockquote><ul><li><p>先发送MQ消息：这个明显是不行的，因为如果消息发送成功，而订单创建失败的话是没办法把消息收回来的</p></li><li><p>先创建订单记录：如果订单创建成功后MQ消息发送失败抛出异常，因为两个操作都在本地事务中所以订单数据是可以回滚的。这个方案看似没问题，但是网络是不可靠的。如果 MQ 的响应因为网络原因没有收到，所以在面对不确定的结果只好进行回滚；但是 MQ 端又确实是收到了这条消息的，只是回给客户端的响应丢失了。这会导致发送端回滚，而接收端执行业务导致不一致。</p></li></ul><h2 id="事务消息原理"><a href="#事务消息原理" class="headerlink" title="事务消息原理"></a>事务消息原理</h2><p>{F19453, width=800}</p><p>主要的逻辑分为两个流程：</p><ul><li>事务消息发送及提交：</li></ul><p>发送half消息<br>MQ服务端响应消息写入结果<br>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）<br>根据本地事务状态执行 Commit 或者 Rollback（Commit操作生成消息索引，消息对消费者可见）</p><ul><li>回查流程：</li></ul><p>对于长时间没有 Commit/Rollback 的事务消息（pending 状态的消息），从服务端发起一次回查<br>Producer 收到回查消息，检查回查消息对应的本地事务状态<br>根据本地事务状态，重新 Commit 或者 Rollback</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>{F19455, width=600}</p><h2 id="最终一致性实现"><a href="#最终一致性实现" class="headerlink" title="最终一致性实现"></a>最终一致性实现</h2><p>从上面的原理可以发现事务消息仅仅只是保证本地事务和MQ消息发送的原子性，而投递到MQ服务器后，并无法保证消费者一定能消费成功。如果消费端消费失败，可以记录异常信息然后人工处理。回滚上游服务的数据并不是个好的选择(因为两者是解耦的，而且复杂度太高)</p><p>我们可以利用 MQ 的两个特性 <strong>重试</strong> 和 <strong>死信队列</strong> 来协助消费端处理：</p><ul><li>消费失败后进行一定次数的重试</li><li>重试后也失败的话该消息丢进死信队列里</li><li>另外起一个线程监听消费死信队列里的消息，记录日志并且预警</li></ul><p>因为有重试， 所以消费者需要实现<strong>幂等性</strong></p><blockquote><p>幂等性是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生副作用，比如订单就算多次点击支付也只有一次能支付成功</p></blockquote><h2 id="spring-cloud-stream-aliyunMQ实现事务消息"><a href="#spring-cloud-stream-aliyunMQ实现事务消息" class="headerlink" title="spring cloud stream + aliyunMQ实现事务消息"></a>spring cloud stream + aliyunMQ实现事务消息</h2><h3 id="坏境"><a href="#坏境" class="headerlink" title="坏境"></a>坏境</h3><ul><li>spring boot 2.2.0</li><li>spring cloud Hoxton.M3</li><li>stream 0.2.2</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>#stream#阿里云控制台rocketmq的配置#tcp外网连接需要mq实例idmq.instance-id=MQ_INST_????_BbwSzZdg#必要 事务消息transactionListener连接aliyunmq需要rocketmq.producer.access-key=xxxxrocketmq.producer.secret-key=xxxxspring.cloud.stream.default-binder=rocketmqspring.cloud.stream.rocketmq.binder.name-server=MQ_INST_????_BbwSzZdg.mq-internet-access.mq-internet.aliyuncs.com:80spring.cloud.stream.rocketmq.binder.access-key=xxxxspring.cloud.stream.rocketmq.binder.secret-key=xxxx#事务消息生产者#相当于topic 需要现在控制台创建account-transaction这个topic 这是个事务消息的topicspring.cloud.stream.bindings.output-transaction.destination=${mq.instance-id}%account-transactionspring.cloud.stream.rocketmq.bindings.output-transaction.producer.transactional=truespring.cloud.stream.rocketmq.bindings.output-transaction.producer.group=${mq.instance-id}%GID-ACCOUNT-TRANSACTIONAL-PRODUCER#事务消息消费者spring.cloud.stream.bindings.input-transactional.destination=${mq.instance-id}%account-transactionspring.cloud.stream.bindings.input-transactional.group=${mq.instance-id}%GID-ACCOUNT-TRANSACTIONAL-CONSUMER#二级分类tag 配置消费者消费的tag 生产者可在发送时指定tagspring.cloud.stream.rocketmq.bindings.input-transactional.consumer.tags=recharge||freeze||withdraw||dedution||account#失败的消息进入死信队列spring.cloud.stream.rocketmq.bindings.input-transactional.consumer.delay-level-when-next-consume=-1#尝试次数 重试一次spring.cloud.stream.bindings.input-transactional.consumer.max-attempts=2#死信队列spring.cloud.stream.bindings.inputDlq.destination=%DLQ%${spring.cloud.stream.bindings.input-transactional.group}spring.cloud.stream.bindings.inputDlq.group=${mq.instance-id}%GID-DLQ-ACCOUNT-TRANSACTIONAL</code></pre><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-stream-rocketmq&lt;/artifactId&gt;            &lt;version&gt;0.2.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h3 id="生产者output-channel"><a href="#生产者output-channel" class="headerlink" title="生产者output channel"></a>生产者output channel</h3><pre><code>public interface AccountOutput {    String TRANSACTION_OUTPUT = &quot;output-transaction&quot;;    /**     * 事务消息生产者pipe     */    @Output(TRANSACTION_OUTPUT)    MessageChannel transactionOutput();}</code></pre><h3 id="事务消息生产者"><a href="#事务消息生产者" class="headerlink" title="事务消息生产者"></a>事务消息生产者</h3><pre><code>@EnableBinding(AccountOutput.class)public class AccountTransactionProducer {    @Autowired    private AccountOutput accountOutput;    /**     * 生产者生产消息     */    public void sendTransactional(Object obj, String tag) {        accountOutput.transactionOutput().send(buildTransactionalMessage(obj, tag));    }    private Message buildTransactionalMessage(Object obj, String tag) {        return MessageBuilder.withPayload(JSON.toJSONString(obj))                .setHeader(RocketMQHeaders.TAGS, tag)                .setHeader(RocketMQHeaders.TRANSACTION_ID, UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;))                .setHeader(MessageConst.PROPERTY_TRANSACTION_CHECK_TIMES, AccountConst.TRANSACTION_CHECK_TIMES)                .build();    }}</code></pre><h3 id="消费者input-channel"><a href="#消费者input-channel" class="headerlink" title="消费者input channel"></a>消费者input channel</h3><pre><code>public interface AccountInput {    String INPUT = &quot;input-transactional&quot;;    /**     * 消费者pipe     */    @Input(INPUT)    SubscribableChannel input();}</code></pre><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><pre><code>@EnableBinding(AccountInput.class)@Slf4jpublic class AccountConsumer {    /**     * 消费者消费消息     */    @StreamListener(AccountInput.INPUT)    public void receive(Message&lt;String&gt; message) {        log.info(&quot;【SpringCloud Stream】StreamListener.stream={}&quot;, JSON.toJSONString(message));    }}</code></pre><h3 id="事务消息监听（本地事务执行与半消息回查）"><a href="#事务消息监听（本地事务执行与半消息回查）" class="headerlink" title="事务消息监听（本地事务执行与半消息回查）"></a>事务消息监听（本地事务执行与半消息回查）</h3><pre><code>@Slf4j@RocketMQTransactionListener(txProducerGroup = &quot;MQ_INST_1734053594575120_BbwSzZdg%GID-ACCOUNT-TRANSACTIONAL-PRODUCER&quot;)public class AccountTransactionListener implements RocketMQLocalTransactionListener {    /**     * 处理本地事务     */    @Override    public RocketMQLocalTransactionState executeLocalTransaction(Message message, Object arg) {        try {      /**         * 在这里如果要获取payload的话 应使用         * String payload = new String((byte[]) message.getPayload());         * 直接获取的payload为byte[] 需要转为String         */            MessageHeaders headers = message.getHeaders();            String transactionalId = (String) headers.get(RocketMQHeaders.TRANSACTION_ID);            // 本地业务            log.info(&quot;开始执行本地事务&quot;);            // ...            log.info(&quot;本地事务执行成功&quot;);            return RocketMQLocalTransactionState.COMMIT;        } catch (Exception e) {            log.error(&quot;发生异常 消息回滚&quot;);            return RocketMQLocalTransactionState.ROLLBACK;        }    }    /**     * 若在本地事务执行过程中缺少二次确认消息或生产者处于等待状态     * MQ Server将向同一组中的每个生产者发送检查消息     */    @Override    public RocketMQLocalTransactionState checkLocalTransaction(Message message) {        log.info(&quot;由于生产者没有发送确认消息，启用消息回查&quot;);        try {            MessageHeaders headers = message.getHeaders();            String transactionalId = (String) headers.get(RocketMQHeaders.TRANSACTION_ID);            // 检查业务 往表里加一个TRANSACTION_ID以便于回查? 或是redis设置一个缓存key            // ...            return RocketMQLocalTransactionState.COMMIT;        } catch (Exception e) {            return RocketMQLocalTransactionState.ROLLBACK;        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>spring cloud</category>
      
      <category>spring cloud stream</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring cloud stream</tag>
      
      <tag>spring cloud</tag>
      
      <tag>rocketmq</tag>
      
      <tag>事务消息</tag>
      
      <tag>aliyunmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lombok注解</title>
    <link href="undefined2019/12/26/lombok%E6%B3%A8%E8%A7%A3/"/>
    <url>2019/12/26/lombok%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="常用的lombok注解"><a href="#常用的lombok注解" class="headerlink" title="常用的lombok注解"></a>常用的lombok注解</h4><ul><li>@Data</li></ul><blockquote><p>包含了@ToString @EqualsAndHashCode @Getter @Setter<br>@ToString等可使用callSuper=true来引入父类属性 用exclude来排除属性</p></blockquote><ul><li><p>@Value</p><blockquote><p>跟@Data差不多 但所有属性会为final</p></blockquote></li><li><p>@NoArgsConstructor</p><blockquote><p>无参构造器 可用access = AccessLevel.PRIVATE来标识这是个私有构造器</p></blockquote></li><li><p>@AllArgsConstructor</p></li><li><p>@Accessors(chain = true)</p><blockquote><p>对象链式构造</p></blockquote></li><li><p>@Builder</p></li><li><p>@Slf4J</p></li></ul><h5 id="idea使用lombok"><a href="#idea使用lombok" class="headerlink" title="idea使用lombok"></a>idea使用lombok</h5><p>plugins 安装lombok插件</p><h5 id="pom引入依赖"><a href="#pom引入依赖" class="headerlink" title="pom引入依赖"></a>pom引入依赖</h5><pre><code>&lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;version&gt;1.18.10&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;      &lt;/dependency&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>spring lombok</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring cloud stream</title>
    <link href="undefined2019/12/11/springcloud%20stream/"/>
    <url>2019/12/11/springcloud%20stream/</url>
    
    <content type="html"><![CDATA[<h1 id="spring-cloud-stream"><a href="#spring-cloud-stream" class="headerlink" title="spring cloud stream"></a>spring cloud stream</h1><h6 id="一个构建消息驱动微服务的框架"><a href="#一个构建消息驱动微服务的框架" class="headerlink" title="一个构建消息驱动微服务的框架"></a>一个构建消息驱动微服务的框架</h6><h3 id="springcloud-stream架构"><a href="#springcloud-stream架构" class="headerlink" title="springcloud stream架构"></a>springcloud stream架构</h3><p><img src="https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180528204400011-1996551371.png" srcset="/img/loading.gif" alt=""></p><p>应用程序通过通道(channels): inputs(相当于消费者consumer，它是从队列中接收消息的) 或者 outputs(相当于生产者producer，它是从队列中发送消息的) 来与 Spring Cloud Stream 中binder 交互，binder 负责与消息中间件交互。通道通过指定中间件的Binder实现与外部代理连接。业务开发者不再关注具体消息中间件，只需关注Binder对应用程序提供的抽象概念来使用消息中间件实现业务即可。</p><p>通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。</p><blockquote><p>notes: 消息的发布（Publish）和订阅（Subscribe）是事件驱动的经典模式。Spring Cloud Stream 的数据交互也是基于这个思想。生产者把消息通过某个 destination 广播出去。其他的微服务，通过订阅特定 destination 来获取广播的消息来触发业务的进行。这种模式，极大的降低了生产者与消费者之间的耦合。即使有新的应用的引入，也不需要破坏当前系统的整体结构。</p></blockquote><h2 id="SpringCloud-Stream消息驱动优缺点"><a href="#SpringCloud-Stream消息驱动优缺点" class="headerlink" title="SpringCloud Stream消息驱动优缺点"></a>SpringCloud Stream消息驱动优缺点</h2><h3 id="解耦合"><a href="#解耦合" class="headerlink" title="解耦合"></a>解耦合</h3><p>消息中间件的架构不同。比方说RabbitMQ和Kafka，RabbitMQ有exchange，kafka有Topic，partitions分区，这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，要往另外一种消息队列进行迁移，这时候很多东西改，因为它跟我们的系统耦合了。这时候springcloud stream给我们提供了一种解耦合的方式。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>集成的mq较少 目前仅有rabbitmq和kafka rocketmq未完全集成</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="一个简单的配置-以阿里云控制台rocketmq为例"><a href="#一个简单的配置-以阿里云控制台rocketmq为例" class="headerlink" title="一个简单的配置 以阿里云控制台rocketmq为例"></a>一个简单的配置 以阿里云控制台rocketmq为例</h3><ul><li>pom依赖 使用最新的release 低版本的配置没最新的全</li></ul><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-stream-rocketmq&lt;/artifactId&gt;            &lt;version&gt;0.2.2.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><ul><li>properties</li></ul><blockquote><p>notes: aliyun控制台的rocketmq tcp公网连接配置</p></blockquote><pre><code>mq.instance-id=MQ_INST_1734053594575120_BbwSzZdgspring.cloud.stream.default-binder=rocketmqspring.cloud.stream.rocketmq.binder.name-server=MQ_INST_1734053594575120_BbwSzZdg.mq-internet-access.mq-internet.aliyuncs.com:80spring.cloud.stream.rocketmq.binder.access-key=xxxspring.cloud.stream.rocketmq.binder.secret-key=xxx#普通消息生产者#相当于topic 需要先在控制台创建account这个topicspring.cloud.stream.bindings.output.destination=${mq.instance-id}%account#消费者spring.cloud.stream.bindings.input.destination=${mq.instance-id}%account#分组 需要现在控制台创建GID-ACCOUNT这个groupspring.cloud.stream.bindings.input.group=${mq.instance-id}%GID-ACCOUNT</code></pre><ul><li>消费者</li></ul><pre><code>@EnableBinding(AccountInput.class)@Slf4j/** * 实例消费者 * 可在service上使用@EnableBinding绑定一个input channels接口 * 再在方法上使用@StreamListener监听一个input channel即可接受消息 * 至于input channel订阅的topic tag在properties文件配置 */public class AccountConsumer {    /**     * 消费者消费消息     */    @StreamListener(AccountInput.INPUT)    public void receive(Message&lt;String&gt; message) {        log.info(&quot;接收到消费信息&quot;);        log.info(message.getPayload());        log.info(message.getHeaders().toString());        log.info(&quot;【SpringCloud Stream】StreamListener.stream={}&quot;, JSON.toJSONString(message));    }}</code></pre><ul><li>生产者</li></ul><pre><code>@EnableBinding(AccountOutput.class)public class AccountProducer {    @Autowired    private AccountOutput accountOutput;    /**     * 生产者生产消息     */    public boolean send(Object obj) {        return accountOutput.output().send(buildMessage(obj));    }    private Message buildMessage(Object obj) {        return MessageBuilder.withPayload(JSON.toJSONString(obj))                .build();    }}</code></pre><ul><li>生产者 消费者channels就不列出惹 使用@Input或@Output绑定channels即可</li></ul><h2 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h2><h3 id="binder"><a href="#binder" class="headerlink" title="binder"></a>binder</h3><p>通过定义binder作为中间层，实现了应用程序与消息中间件(Middleware)细节之间的隔离。通过向应用程序暴露统一的通道，使得应用程序不需要再考虑各种不同的消息中间件的实现。当需要更换其他消息中间件产品时，需要做的就是修改binder的配置而不需要修改任何应用逻辑。甚至可以任意的改变中间件的类型而不需要修改一行代码。</p><p>为构造Binding提供了 2 个方法，分别是 bindConsumer 和 bindProducer ，它们分别用于构造生产者和消费者。Binder使Spring Cloud Stream应用程序可以灵活地连接到中间件。</p><h3 id="binding"><a href="#binding" class="headerlink" title="binding"></a>binding</h3><p>Binding 是连接应用程序跟消息中间件的桥梁，用于消息的消费和生产，由binder创建。</p><h3 id="Input"><a href="#Input" class="headerlink" title="@Input"></a>@Input</h3><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><pre><code>public interface Consumer {    @Input(&quot;input&quot;)    SubscribableChannel input();}</code></pre><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>用于接收消息</li><li>为每个binding生成channel实例</li><li>指定channel名称</li><li>在spring容器中生成一个名为input，类型为SubscribableChannel的bean</li><li>在spring容器中生成一个类，实现Consumer接口。</li></ul><h3 id="output"><a href="#output" class="headerlink" title="@output"></a>@output</h3><p>类似@input 用于生产消息</p><h3 id="InboundChannelAdapter"><a href="#InboundChannelAdapter" class="headerlink" title="@InboundChannelAdapter"></a>@InboundChannelAdapter</h3><p>让定义的方法生产消息</p><pre><code>@Bean@InboundChannelAdapter(value = Source.OUTPUT,        poller = @Poller(fixedDelay = &quot;10&quot;, maxMessagesPerPoll = &quot;1&quot;))public MessageSource&lt;String&gt; test() {    return () -&gt; new GenericMessage&lt;&gt;(&quot;Hello Spring Cloud Stream&quot;);}</code></pre><blockquote><p>用 InboundChannelAdapter 注解的方法上即使有参数也没用。即下面test方法不要有参数。</p></blockquote><ul><li>fixedDelay：多少毫秒发送1次</li><li>maxMessagesPerPoll：一次发送几条消息。</li></ul><h3 id="ServiceActivator"><a href="#ServiceActivator" class="headerlink" title="@ServiceActivator"></a>@ServiceActivator</h3><p>表示方法能够处理消息或消息有效内容，监听input消息，用方法体的代码处理，然后输出到output中。</p><h4 id="例如消息异常处理"><a href="#例如消息异常处理" class="headerlink" title="例如消息异常处理"></a>例如消息异常处理</h4><pre><code>#这里set input channel订阅的destination及所在的group@ServiceActivator(inputChannel = &quot;input-destination.input-group.errors&quot;, outputChannel = &quot;xxx&quot;)    public Object handleError(ErrorMessage message) {        Throwable throwable = message.getPayload();        log.error(&quot;截获异常message:{}&quot;, throwable.getMessage());        Message&lt;?&gt; originalMessage = message.getOriginalMessage();        if (null != originalMessage) {            log.info(&quot;原始消息体 = {}&quot;, new String((byte[]) originalMessage.getPayload()));        }        return &quot;xxx&quot;;    }</code></pre><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="@Transformer"></a>@Transformer</h3><p>和 ServiceActivator 类似，表示方法能够转换消息，消息头，或消息有效内容</p><h3 id="Processor-消息中转站"><a href="#Processor-消息中转站" class="headerlink" title="Processor 消息中转站"></a>Processor 消息中转站</h3><p>spring-cloud-stream给我们提供了一个Processor接口，用于将消息处理后再发送出去，相当于一个消息中转站</p><p>从源码可看出Processor扩展了Source(生产者channels)和Sink(消费者Channels)。</p><pre><code>public interface Processor extends Source, Sink {}</code></pre><h4 id="仍是rocketmq为例（rocketmq里只要是消息接收者都需要group）"><a href="#仍是rocketmq为例（rocketmq里只要是消息接收者都需要group）" class="headerlink" title="仍是rocketmq为例（rocketmq里只要是消息接收者都需要group）"></a>仍是rocketmq为例（rocketmq里只要是消息接收者都需要group）</h4><ul><li>生产者 properties</li></ul><p><code>spring.cloud.stream.bindings.output.destination=${mq.instance-id}%account</code></p><ul><li>中转者 properties</li></ul><pre><code>spring.cloud.stream.bindings.output.destination=${mq.instance-id}%account-transspring.cloud.stream.bindings.input.destination=${mq.instance-id}%account</code></pre><pre><code>@Slf4j@EnableBinding(Processor.class)public class TransFormService {    @ServiceActivator(inputChannel = Processor.INPUT, outputChannel = Processor.OUTPUT)    public Object transform(Object payload){        log.info(&quot;消息中转站：{}&quot;, payload);        return payload;    }}</code></pre><ul><li>接收者</li></ul><p><code>spring.cloud.stream.bindings.input.destination=${mq.instance-id}%account-trans</code></p><h3 id="Consumer-Groups"><a href="#Consumer-Groups" class="headerlink" title="Consumer Groups"></a>Consumer Groups</h3><p>防止同一个事件被重复消费，只要把这些应用放置于同一个 “group” 中，就能够保证消息只会被一个group其中的一个应用消费一次。</p><blockquote><p>rocketmq里消费者是一定有分组的 如<code>spring.cloud.stream.bindings.input.group=${mq.instance-id}%GID-ACCOUNT</code></p></blockquote><h3 id="消息分区-partition"><a href="#消息分区-partition" class="headerlink" title="消息分区 partition"></a>消息分区 partition</h3><blockquote><p>Spring Cloud Stream对给定应用的多个实例之间分隔数据予以支持。一个或者多个生产者应用实例给多个消费者应用实例发送消息并确保相同特征的数据被同一消费者实例处理。</p></blockquote><p>也就是说Spring Cloud Stream可以根据分区分配算法将相同特征的消息（比如id  % 2 = 1）分配给同一个实例消费。</p><blockquote><p>notes: Spring Cloud Stream对分割的进程实例实现进行了抽象。使得Spring Cloud Stream 为不具备分区功能的消息中间件（RabbitMQ）也增加了分区功能扩展。</p></blockquote><ul><li>消费者</li></ul><pre><code>spring.cloud.stream.binginds.input.consumer.partitioned=true#分区数量spring.cloud.stream.instance-count=2</code></pre><ul><li>生产者<pre><code>#分区的主键，例如payload.id只是一个对象的id用于做为Keyspring.cloud.stream.bindings.output.producer.partitionKeyExpression=payload.id#Key和分区数量进行取模去分配消息，这里分区数量配置为2spring.cloud.stream.bindings.output.producer.partitionCount=2</code></pre></li></ul><h3 id="返回确认ack"><a href="#返回确认ack" class="headerlink" title="返回确认ack"></a>返回确认ack</h3><p>使用@SendTo注解 或使用消息中转的方式亦可</p><pre><code>@StreamListener(&quot;input-channel&quot;)@SendTo(&quot;output-channel&quot;)public Object receiveFromInput(Object payload){        return &quot;ack&quot;;    }</code></pre><h3 id="stream-消息过滤"><a href="#stream-消息过滤" class="headerlink" title="stream 消息过滤"></a>stream 消息过滤</h3><ul><li>使用condition 使用所有mq</li></ul><pre><code>#producerMessageBuilder.setHeader(&quot;service-header&quot;, &quot;mycondition&quot;).build();#consumer@StreamListener(value = Sink.INPUT, condition = &quot;headers[&#39;service-header&#39;]==&#39;mycondition&#39;&quot;)</code></pre><ul><li>使用tag 只适用rocketmq</li></ul><pre><code>#producerMessageBuilder.setHeader(RocketMQHeaders.TAGS, &quot;deduction&quot;).build();MessageBuilder.setHeader(RocketMQHeaders.TAGS, &quot;withdraw&quot;).build();#consumer propertiesspring.cloud.stream.rocketmq.bindings.input.consumer.tags= deduction||withdraw</code></pre><ul><li>使用sql过滤 rocketmq</li></ul><blockquote><p>首先要确认开启了rocketmq的sql过滤</p></blockquote><pre><code>#producerMessageBuilder.setHeader(&quot;amount&quot;, &quot;100&quot;).build();#consumer propertiesspring.cloud.stream.rocketmq.bindings.input.consumer.sql=&quot;amount&gt;=100&quot;</code></pre><p>###</p><p>官网: <a href="https://spring.io/projects/spring-cloud-stream" target="_blank" rel="noopener">https://spring.io/projects/spring-cloud-stream</a></p>]]></content>
    
    
    <categories>
      
      <category>spring cloud</category>
      
      <category>spring cloud stream</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring cloud stream</tag>
      
      <tag>mq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongotemplate</title>
    <link href="undefined2019/11/25/mongotemplate/"/>
    <url>2019/11/25/mongotemplate/</url>
    
    <content type="html"><![CDATA[<h4 id="mongotemplate"><a href="#mongotemplate" class="headerlink" title="mongotemplate"></a>mongotemplate</h4><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p><code>spring.data.mongodb.uri=mongodb://xxxx:27017/xxxx</code></p><h5 id="使用MongoTemplate查询"><a href="#使用MongoTemplate查询" class="headerlink" title="使用MongoTemplate查询"></a>使用MongoTemplate查询</h5><ul><li>单条件</li></ul><p><code>Query query = Query.query(Criteria.where(&quot;id&quot;).is(&quot;1&quot;));</code></p><ul><li>or &amp; and</li></ul><pre><code>Criteria criteria = new Criteria();criteria.orOperator(Criteria.where(&quot;title&quot;).is(&quot;a&quot;),Criteria.where(&quot;name&quot;).is(&quot;b&quot;));criteria.andOperator(Criteria.where(&quot;time&quot;).ge(start),Criteria.where(&quot;time&quot;).is(end));Query query = new Query(criteria);</code></pre><h5 id="一个字段多约束需要andOperator"><a href="#一个字段多约束需要andOperator" class="headerlink" title="一个字段多约束需要andOperator"></a>一个字段多约束需要andOperator</h5><ul><li>sort</li></ul><pre><code>Query query = new Query();Sort sort = new Sort(new Sort.Order(Sort.Direction.DESC,&quot;id&quot;));query.with(sort);</code></pre><h5 id="2-x后是Sort-by"><a href="#2-x后是Sort-by" class="headerlink" title="2.x后是Sort.by"></a>2.x后是Sort.by</h5><ul><li>分页</li></ul><pre><code>Query query = new Query();query.skip(1).limit(3);</code></pre><ul><li>update</li></ul><pre><code>Update update = new Update();update.set(&quot;name&quot;,&quot;a&quot;);update.set(&quot;title&quot;,&quot;b&quot;);UpdateResult wr = mongoTemplate.updateFirst(query, update, collect.class);</code></pre><h5 id="ne为不等于"><a href="#ne为不等于" class="headerlink" title="ne为不等于"></a>ne为不等于</h5><h5 id="not为字段不存在"><a href="#not为字段不存在" class="headerlink" title="not为字段不存在"></a>not为字段不存在</h5><ul><li>正则匹配查询</li></ul><pre><code>query.addCriteria(Criteria.where(&quot;key&quot;).regex(&quot;.*?\\&quot; + value + &quot;.*&quot;)</code></pre><ul><li>分次批量拉取数据 不用分页 因为分页到后期会很慢</li></ul><pre><code>/**     * 获取id后的某一时间段内的size个的任务绩效     * @param id  （mongo中存储的id）     * @param startTime     * @param endTime     * @return     */    public &lt;T extends PerformanceEntity&gt; List&lt;T&gt; getTaskPerformanceList(String id, Date startTime, Date endTime, Class&lt;T&gt; t) {        return getTaskPerformanceList(size, id, startTime, endTime, t);    }    /**     * 获取id后的某一时间段内的size个的标注/质检任务绩效     * @param size     * @return     */    public &lt;T extends PerformanceEntity&gt; List&lt;T&gt; getTaskPerformanceList(int size, String id, Date startTime, Date endTime, Class&lt;T&gt; t) {        Query query = new Query();        Criteria criteria = new Criteria();        criteria.andOperator(Criteria.where(CREATE_TIME).gte(startTime), Criteria.where(CREATE_TIME).lt(endTime));        query.addCriteria(criteria);        ObjectId objectId;        if (StringUtils.isNotBlank(id)) {            objectId = new ObjectId(id);            query.addCriteria(Criteria.where(ID).gt(objectId));        }        query.with(Sort.by(Sort.Direction.ASC, ID));        query.limit(size);        return mongoTemplate.find(query, t);    }</code></pre><h5 id="id第一次传null"><a href="#id第一次传null" class="headerlink" title="id第一次传null"></a>id第一次传null</h5>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>mongotemplate</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>mongotemplate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis plus</title>
    <link href="undefined2019/11/25/mybatis-plus/"/>
    <url>2019/11/25/mybatis-plus/</url>
    
    <content type="html"><![CDATA[<h4 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis Plus"></a>Mybatis Plus</h4><h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><pre><code>&lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;        &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h5 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h5><pre><code>spring.datasource.url=jdbc:mysql://xxxx:3306/xxxx?allowMultiQueries=truespring.datasource.username=rootspring.datasource.password=xxxx</code></pre><h5 id="启动类加上MapperScan注解"><a href="#启动类加上MapperScan注解" class="headerlink" title="启动类加上MapperScan注解"></a>启动类加上MapperScan注解</h5><p><code>@MapperScan(&quot;com.baomidou.mybatisplus.samples.quickstart.mapper&quot;)</code></p><h5 id="编写实体类"><a href="#编写实体类" class="headerlink" title="编写实体类"></a>编写实体类</h5><pre><code>@Datapublic abstract class BaseSqlEntity {    /**     * 主键     */    @TableId(type = IdType.ID_WORKER)    private Long id;    /**     * 创建时间     */    private Date createTime;    /**     * 创建者     */    private String createUser;    /**     * insert实体时调用     */    public void setCreateFields(String userId) {        this.createTime = new Date();        this.createUser = userId;    }}@TableName(&quot;t_user&quot;)@Datapublic class User extends BaseSqlEntity {    /**     * 账户名     */    private String userName;}</code></pre><h5 id="编写Mapper"><a href="#编写Mapper" class="headerlink" title="编写Mapper"></a>编写Mapper</h5><pre><code>public interface UserMapper extends BaseMapper&lt;User&gt; {}</code></pre><h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class SampleTest {    @Autowired    private UserMapper userMapper;    @Test    public void testSelect() {        System.out.println((&quot;----- selectAll method test ------&quot;));        List&lt;User&gt; userList = userMapper.selectList(null);        Assert.assertEquals(5, userList.size());        userList.forEach(System.out::println);    }}</code></pre><h5 id="分页插件-启动类配置"><a href="#分页插件-启动类配置" class="headerlink" title="分页插件 启动类配置"></a>分页插件 启动类配置</h5><pre><code>@Bean    public PaginationInterceptor paginationInterceptor() {        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false        // paginationInterceptor.setOverflow(false);        // 设置最大单页限制数量，默认 500 条，-1 不受限制        // paginationInterceptor.setLimit(500);        return paginationInterceptor;    }</code></pre><h5 id="官方教程"><a href="#官方教程" class="headerlink" title="官方教程"></a>官方教程</h5><p><a href="https://mp.baomidou.com/" target="_blank" rel="noopener">https://mp.baomidou.com/</a></p><h5 id="note"><a href="#note" class="headerlink" title="note"></a>note</h5><ul><li>使用lambdaQueryMapper lambdaUpdateMapper</li><li>selectOne需要手动加上last(‘limit 1’)</li><li>分页从1开始</li></ul>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>mybatis plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>mybatis plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>devtools</title>
    <link href="undefined2019/11/12/devtools/"/>
    <url>2019/11/12/devtools/</url>
    
    <content type="html"><![CDATA[<h3 id="devtools的使用"><a href="#devtools的使用" class="headerlink" title="devtools的使用"></a>devtools的使用</h3><p>####原理</p><blockquote><p>ide在发现代码有更改之后，重新启动应用，但是速度比手动停止后再启动更快。深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类，称为restart ClassLoader。这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间。即devtools会监听classpath下的文件变动，并且会立即重启应用（发生在保存时机）</p></blockquote><h4 id="不生效路径"><a href="#不生效路径" class="headerlink" title="不生效路径"></a>不生效路径</h4><p>默认情况下，/META-INF/maven，/META-INF/resources，/resources，/static，/templates，/public这些文件夹下的文件修改不会使应用重启，但是会重新加载（devtools内嵌了一个LiveReload server，当资源发生改变时，浏览器刷新</p><blockquote><p>可以使用spring.devtools.restart.exclude属性来自定义排除的资源。例如，要仅排除/static，/public可以设置以下属性：<br><code>spring.devtools.restart.exclude=static/**,public/**</code></p></blockquote><h4 id="pom文件引入devtools依赖"><a href="#pom文件引入devtools依赖" class="headerlink" title="pom文件引入devtools依赖"></a>pom文件引入devtools依赖</h4><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;</code></pre><h5 id="optional-true-依赖不会传递"><a href="#optional-true-依赖不会传递" class="headerlink" title="optional=true,依赖不会传递"></a>optional=true,依赖不会传递</h5><h4 id="maven插件配置"><a href="#maven插件配置" class="headerlink" title="maven插件配置"></a>maven插件配置</h4><pre><code>            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;fork&gt;true&lt;/fork&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;</code></pre><h4 id="开启自动编译"><a href="#开启自动编译" class="headerlink" title="开启自动编译"></a>开启自动编译</h4><p>设置里compiler勾选Build Project automatically</p><h4 id="开启运行时自动编译"><a href="#开启运行时自动编译" class="headerlink" title="开启运行时自动编译"></a>开启运行时自动编译</h4><p>command+shift+alt+/ 打开registry勾选compiler.automake.allow.when.app.running</p><h4 id="重新启动即配置完成"><a href="#重新启动即配置完成" class="headerlink" title="重新启动即配置完成"></a>重新启动即配置完成</h4><h4 id="更改代码后不需手动重启-build后即自动重启"><a href="#更改代码后不需手动重启-build后即自动重启" class="headerlink" title="更改代码后不需手动重启 build后即自动重启"></a>更改代码后不需手动重启 build后即自动重启</h4><h4 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h4><p><code>spring.devtools.restart.enabled=false</code></p><h4 id="监听其他路径"><a href="#监听其他路径" class="headerlink" title="监听其他路径"></a>监听其他路径</h4><p><code>spring.devtools.restart.additional-paths=</code></p>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>devtools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>devtools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective Java</title>
    <link href="undefined2019/11/06/Effective%20JAVA%E7%AC%94%E8%AE%B0/"/>
    <url>2019/11/06/Effective%20JAVA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Effective-Java-note"><a href="#Effective-Java-note" class="headerlink" title="Effective Java note"></a>Effective Java note</h1><h2 id="考虑用静态工厂方法代替构造器"><a href="#考虑用静态工厂方法代替构造器" class="headerlink" title="考虑用静态工厂方法代替构造器"></a>考虑用静态工厂方法代替构造器</h2><h2 id="考虑用bulider模式"><a href="#考虑用bulider模式" class="headerlink" title="考虑用bulider模式"></a>考虑用bulider模式</h2><h2 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h2><h2 id="通过enum类型强化单例属性"><a href="#通过enum类型强化单例属性" class="headerlink" title="通过enum类型强化单例属性"></a>通过enum类型强化单例属性</h2><h2 id="覆盖hashCode时总要覆盖equals"><a href="#覆盖hashCode时总要覆盖equals" class="headerlink" title="覆盖hashCode时总要覆盖equals"></a>覆盖hashCode时总要覆盖equals</h2><h2 id="复合优于继承"><a href="#复合优于继承" class="headerlink" title="复合优于继承"></a>复合优于继承</h2><h2 id="接口优于抽象"><a href="#接口优于抽象" class="headerlink" title="接口优于抽象"></a>接口优于抽象</h2><h2 id="用函数对象表示策略"><a href="#用函数对象表示策略" class="headerlink" title="用函数对象表示策略"></a>用函数对象表示策略</h2><h2 id="enum代替int常量"><a href="#enum代替int常量" class="headerlink" title="enum代替int常量"></a>enum代替int常量</h2><h2 id="坚持使用override注解"><a href="#坚持使用override注解" class="headerlink" title="坚持使用override注解"></a>坚持使用override注解</h2><h2 id="慎用可变参数"><a href="#慎用可变参数" class="headerlink" title="慎用可变参数"></a>慎用可变参数</h2><h2 id="精确答案避免使用float和double-使用int-long-BigDecimal"><a href="#精确答案避免使用float和double-使用int-long-BigDecimal" class="headerlink" title="精确答案避免使用float和double 使用int long BigDecimal"></a>精确答案避免使用float和double 使用int long BigDecimal</h2><h2 id="通过接口引用对象"><a href="#通过接口引用对象" class="headerlink" title="通过接口引用对象"></a>通过接口引用对象</h2><h2 id="executor和task优先于线程"><a href="#executor和task优先于线程" class="headerlink" title="executor和task优先于线程"></a>executor和task优先于线程</h2><h2 id="并发工具优先于wait和notify"><a href="#并发工具优先于wait和notify" class="headerlink" title="并发工具优先于wait和notify"></a>并发工具优先于wait和notify</h2>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>enum优化switch case</title>
    <link href="undefined2019/10/25/enum%E4%BC%98%E5%8C%96switch/"/>
    <url>2019/10/25/enum%E4%BC%98%E5%8C%96switch/</url>
    
    <content type="html"><![CDATA[<h1 id="enum优化switch-case"><a href="#enum优化switch-case" class="headerlink" title="enum优化switch case"></a>enum优化switch case</h1><pre><code>public class Outer {    public static void out(String str) {        System.out.println(str);    }    enum Inner {        JACK(1, &quot;jack&quot;) {            @Override            public void handle() {                out(this.getMessage());            }        },        ANNIE(2, &quot;annie&quot;) {            @Override            public void handle() {                out(this.getMessage());            }        };        Integer code;        String message;        Inner(Integer code, String message) {            this.code = code;            this.message = message;        }        public Integer getCode() {            return code;        }        public void setCode(Integer code) {            this.code = code;        }        public String getMessage() {            return message;        }        public void setMessage(String message) {            this.message = message;        }        public abstract void handle();    }    public static void main(String[] args) {        String[] options = new String[] {&quot;JACK&quot;, &quot;ANNIE&quot;};        Arrays.stream(options).forEach((str) -&gt; {            Inner.valueOf(str).handle();        });    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>enum</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javase</tag>
      
      <tag>enum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全局异常</title>
    <link href="undefined2019/10/23/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>2019/10/23/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h1><h4 id="全局异常捕捉"><a href="#全局异常捕捉" class="headerlink" title="全局异常捕捉"></a>全局异常捕捉</h4><pre><code>@ControllerAdvice@RestControllerpublic class AllExceptionHandler {    /**     * 处理所有其它异常     */    @ExceptionHandler(Exception.class)    public Result handleOtherException(Exception e) {        String message = &quot;[handleOtherException] &quot; + ExceptionUtil.exception2Str(e);        return Result.fail(ResultEnum.serverError, message);    }    /**     * 处理noHandler异常     */    @ExceptionHandler(NoHandlerFoundException.class)    public Result handleNoHandlerFoundException() {        return Result.fail(ResultEnum.handlerNotExist);    }    @ExceptionHandler(ServiceException.class)    public Result handleServiceException(ServiceException e) {        return Result.fail(e.getResultEnum(), e.getExceptionMessage());    }}</code></pre><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><pre><code>public class ServiceException extends RuntimeException {    private ResultEnum resultEnum;    private String exceptionMessage;    public ServiceException(ResultEnum resultEnum) {        this.resultEnum = resultEnum;    }    public ServiceException(ResultEnum resultEnum, String exceptionMessage) {        this.resultEnum = resultEnum;        this.exceptionMessage = exceptionMessage;    }    public ResultEnum getResultEnum() {        return resultEnum;    }    public String getExceptionMessage() {        return exceptionMessage;    }}</code></pre><h4 id="返回结果封装"><a href="#返回结果封装" class="headerlink" title="返回结果封装"></a>返回结果封装</h4><pre><code>@Data@NoArgsConstructor(access = AccessLevel.PRIVATE)public final class Result&lt;T&gt; {    @JSONField(ordinal = 10)    private Boolean success;    @JSONField(ordinal = 20)    private String code;    @JSONField(ordinal = 30)    private String message;    @JSONField(ordinal = 40)    private T data;    public static Result fail(ResultEnum resultEnum) {        Result result = new Result();        result.success = resultEnum.getSuccess();        result.code = resultEnum.getCode();        result.message = resultEnum.getMessage();        result.data = null;        return result;    }    public static Result fail(ResultEnum resultEnum, String message) {        Result result = fail(resultEnum);        if (StringUtils.isNotBlank(message)) {            result.message = message;        }        return result;    }    public static &lt;T&gt; Result success(T data) {        Result result = new Result();        result.setSuccess(ResultEnum.doSuccess.getSuccess());        result.setCode(ResultEnum.doSuccess.getCode());        result.setMessage(ResultEnum.doSuccess.getMessage());        result.data = data;        return result;    }}</code></pre><h4 id="返回码枚举类"><a href="#返回码枚举类" class="headerlink" title="返回码枚举类"></a>返回码枚举类</h4><pre><code>public enum ResultEnum {    doSuccess(true, &quot;artastic-10000&quot;, &quot;成功&quot;),    doFailed(false, &quot;artastic-10001&quot;, &quot;失败&quot;),    private final Boolean success;    private final String code;    private final String message;    ResultEnum(Boolean success, String code, String message) {        this.success = success;        this.code = code;        this.message = message;    }    public Boolean getSuccess() {        return success;    }    public String getCode() {        return code;    }    public String getMessage() {        return message;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>exception</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aop</title>
    <link href="undefined2019/10/23/AOP/"/>
    <url>2019/10/23/AOP/</url>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><pre><code>       &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><h4 id="切面类"><a href="#切面类" class="headerlink" title="切面类"></a>切面类</h4><ul><li>类上加入@Aspect 注解</li><li>使用@Pointcut 定义一个公共的方法，定义切哪个点</li><li>@Before @After @AfterReturning 这三个注解是切的时间点</li><li>使用@Slf4J 进行日志记录</li></ul><pre><code>@Aspect@Slf4J@Componentpublic class HttpAspect {    @Pointcut(&quot;execution(com.javaee.artastic.Artastic.controller.TestController.*(..))&quot;)    public void log(){    }    @Before(&quot;log()&quot;)    public void doBefore(JoinPoint joinPoint){        ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        logg.info(&quot;url={}&quot;,request.getRequestURL());        logg.info(&quot;method = {}&quot;,request.getMethod());        logg.info(&quot;ip = {}&quot;,request.getRemoteAddr());        logg.info(&quot;class_method={}&quot;,joinPoint.getSignature().getDeclaringTypeName()+&quot;.&quot;+ joinPoint.getSignature().getName());        logg.info(&quot;args = {}&quot;,joinPoint.getArgs());    }    @After(&quot;log()&quot;)    public void doAfter(){    }    @AfterReturning(pointcut = &quot;log()&quot;,returning = &quot;object&quot;)    public void doAfterReturning(Object object){        logg.info(&quot;response = {}&quot;,object);    }}</code></pre><pre><code>@Aspectpublic class GetLoginUserAspect {    @Autowired    private TokenManagerService tokenManagerService;    @Autowired    private HttpServletRequest request;    private static Set&lt;String&gt; noTokenMethod;    private static Set&lt;String&gt; ignoreControllers;    static {        noTokenMethod = new HashSet&lt;&gt;();        noTokenMethod.add(&quot;login&quot;);        noTokenMethod.add(&quot;health&quot;);        ignoreControllers = new HashSet&lt;&gt;();        ignoreControllers.add(&quot;com.javaee.artastic.Artastic.controller.TestController&quot;);    }    @Around(&quot;execution(* com.javaee.artastic.Artastic.controller.*.*(..)))&quot;)    public Object advice(ProceedingJoinPoint joinPoint) throws Throwable {        String declaringTypeName = joinPoint.getSignature().getDeclaringTypeName();        if (ignoreControllers.contains(declaringTypeName)) {            return joinPoint.proceed();        }        MethodSignature signature = (MethodSignature) joinPoint.getSignature();        if (noTokenMethod.contains(signature.getMethod().getName())) {            return joinPoint.proceed();        }        String token = StringUtils.getToken(request);        UserVo userVo = tokenManagerService.getUserVoByToken(token);        request.setAttribute(ArtasticConst.LOGIN_USER, userVo);        return joinPoint.proceed();    }}</code></pre><ul><li>在启动类注入</li></ul><pre><code>@SpringBootApplicationpublic class App extends SpringBootServletInitializer {    public static void main( String[] args )    {        SpringApplication.run(App.class, args);    }    @Bean    public GetLoginUserAspect setAutoUserAspect() {        return new GetLoginUserAspect();    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>aop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>aop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jpa</title>
    <link href="undefined2019/10/23/JPA/"/>
    <url>2019/10/23/JPA/</url>
    
    <content type="html"><![CDATA[<h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><p>pom</p><pre><code>       &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>application.yml</p><ul><li>MySQL 5.6</li></ul><pre><code>spring:  profiles:    active: dev  datasource:    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://127.0.0.1:3306/dbgirl?characterEncoding=utf8&amp;useSSL=false    username: root    password: root  jpa:    hibernate:      ddl-auto: update    show-sql: true</code></pre><p>hibernate.hbm2ddl.auto 参数的作用主要用于：自动创建 | 更新 | 验证数据库表结构，有四个值：</p><blockquote><p>create：每次加载 hibernate 时都会删除上一次的生成的表，然后根据 model 类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。</p></blockquote><blockquote><p>create-drop：每次加载 hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。</p></blockquote><blockquote><p>update：最常用的属性，第一次加载 hibernate 时根据 model 类会自动建立起表的结构（前提是先建立好数据库），以后加载 hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。</p></blockquote><blockquote><p>validate：每次加载 hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</p></blockquote><p>添加entity及dao</p>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>jpa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>jpa</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多环境配置</title>
    <link href="undefined2019/10/23/%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>2019/10/23/%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="开发环境和生成环境配置不同的问题"><a href="#开发环境和生成环境配置不同的问题" class="headerlink" title="开发环境和生成环境配置不同的问题"></a>开发环境和生成环境配置不同的问题</h1><ul><li><p>复制2个yml文件，分别是application-dev.yml (开发环境) application-prod.yml（生产环境）</p></li><li><p>修改application-prod.yml（生产环境）文件</p></li></ul><pre><code>server:  port: 8088app:  name:test</code></pre><ul><li>application-dev.yml (开发环境)文件内容</li></ul><pre><code>server:  port: 8099app:  name: test1</code></pre><ul><li>application.yml文件内容,这个就代表使用dev的配置文件</li></ul><pre><code>spring:  profiles:    active: ${environment}</code></pre><ul><li><p>先执行 mvn install 在执行启动 java -jar xxx.jar –spring.profiles.active=prod</p></li><li><p>此时就是访问的prod 的配置8088，（注意我们配置的application.yml 中用的是dev 这个配置文件，但是我们启动的时候加上后面的参数就自动切换到 prod 文件上）</p></li><li><p>或VM Options里添加 -Denvironment=prod</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>spring boot config</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>config</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>swagger</title>
    <link href="undefined2019/10/23/%E6%95%B4%E5%90%88swagger/"/>
    <url>2019/10/23/%E6%95%B4%E5%90%88swagger/</url>
    
    <content type="html"><![CDATA[<h2 id="整合swagger"><a href="#整合swagger" class="headerlink" title="整合swagger"></a>整合swagger</h2><p>SwaggerConfig.java</p><pre><code>@Configuration@EnableSwagger2@EnableWebMvc@ConditionalOnExpression(&quot;${enable.swagger:false}&quot;)public class SwaggerConfig extends WebMvcConfigurerAdapter {    @Bean    public Docket createRestApi() {        ParameterBuilder header = new ParameterBuilder();        List&lt;Parameter&gt; pars = new ArrayList&lt;&gt;();        header.name(&quot;X-Token&quot;)                .description(&quot;user token&quot;)                .modelRef(new ModelRef(&quot;string&quot;))                .parameterType(&quot;header&quot;)                .required(false).build();        pars.add(header.build());        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.javaee.artastic.Artastic.controller&quot;))                .paths(PathSelectors.any())                .build()                .globalOperationParameters(pars);    }    private ApiInfo apiInfo() {        return new ApiInfoBuilder()                .title(&quot;artastic Apis&quot;)                .description(&quot;apis in artastic service&quot;)                .contact(new Contact(null, null, null))                .version(&quot;v1&quot;)                .build();    }    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) {        registry.addResourceHandler(&quot;swagger-ui.html&quot;)                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);        registry.addResourceHandler(&quot;/webjars/**&quot;)                .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);    }}</code></pre><p>application.yml需加上如下配置表示启用swagger</p><pre><code>enable:  swagger: true</code></pre><p>pom依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
      <category>swagger</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>